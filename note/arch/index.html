<!DOCTYPE html>
<html>

<head>
  <title> 高端唯有定制 Arch-Linux折腾记 &middot; Horc-Blog </title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="generator" content="Hugo 0.16" />


<link rel="stylesheet" href="https://horc-fn.github.io/css/vec.css">


<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
<link rel="shortcut icon" href="/favicon.ico">


<link href="" rel="alternate" type="application/rss+xml" title="Horc-Blog" />

</head>

<body>
  <header>
  <div id="bgmusic">
    
  </div>
  <nav>
    <ul>
      
      
      
      <li class="pull-left ">
        <a href="https://horc-fn.github.io/">/horc-blog</a>
      </li>
      
      
      
      <li class="pull-left">
        <a href="https://horc-fn.github.io//grey_hat/">~/灰帽子</a>
      </li>
      
      
      
      <li class="pull-left">
        <a href="https://horc-fn.github.io//note/">~/笔记</a>
      </li>
      
      
      
      <li class="pull-left">
        <a href="https://horc-fn.github.io//essay/">~/随笔</a>
      </li>
      
      
      
      <li class="pull-left">
        <a href="https://horc-fn.github.io//about/">~/关于我</a>
      </li>
      
      
      <li class="pull-right"><a href=""><i class="fa fa-rss"></i></a></li>
      
    </ul>
  </nav>
</header>
  <div class="content">
    
    
    <section class="post">
      <h2 class="post-title"><a href="https://horc-fn.github.io/note/arch/">高端唯有定制 Arch-Linux折腾记</a></h2>
      <span class="post-date">Apr 12, 2016 </span>
      <div class="post-content">
        

<h1 id="序言">序言</h1>

<h2 id="邂逅arch">邂逅Arch</h2>

<p>摸爬滚打,CentOS、Fedora、Ubuntu、Mint、Deepin、Kali等等诸多优秀的系统因种种原因浅尝辄止。据说每个Linux发行版都有对应的哲学,大概因为我个人的小哲学归属于Arch之道,就滚到Arch了。。</p>

<p>先上几张图吸引眼球(<strong>非笔者美化及使用,详见本文参考1</strong>)
<img src="../../img/kon1.jpg" alt="" /></p>

<p>Archlinux 是一个可制定性非常强的Linux 发行版,从一个基本系统开始,如何搭建系统全部都由你掌控,所以一万个人有一万种Arch。
不过Arch的安装过程不怎么友好,把安装过程写下来吧,如果有人也想体验一下Arch,说不定有点用。
&gt; <a href="https://www.archlinux.org/download/">下载Arch镜像请点击这里</a></p>

<h2 id="arch的优劣">Arch的优劣</h2>

<p><strong>优</strong></p>

<ul>
<li>滚动升级,再也无需因为发行版的更新而重装系统</li>
<li>软件包很新,第一时间尝试新的软件,包括最新内核</li>
<li>详细的wiki以及pacman近乎完美地处理包依赖关系</li>
</ul>

<p><strong>劣</strong></p>

<ul>
<li>用Archlinux 中文社区中广为留传的话解释:多滚多死,少滚少死,不滚等死。</li>
</ul>

<hr />

<h1 id="基础安装">基础安装</h1>

<p>根据官网描述,Arch Linux能在任何内存空间不小于256MB 的i686兼容机上运行。最基本的base组中包含的包将占用约 800MB存储空间。<strong>本文通过将镜像写入U盘进行启动安装.</strong></p>

<h2 id="安装须知">安装须知</h2>

<ul>
<li>archlinux 有别于其他发行版的地方是:这货没有安装程序！ 是的,arch没有安装程序这个概念。
不过没有关系,如果你对arch感到陌生,之后内容或许能帮你从无到有搭建起自己的archlinux。</li>
<li>arch 和 gentoo 一样极度依赖网络环境, 如果你无法在安装过程中提供良好的网络环境,请尝试组合键<strong><code>ctrl+w</code></strong>。</li>
<li>另外笔者PC只有BIOS,所以使用的是BIOS+MBR的安装,虽然文中提及了一些UEFI+GPT的安装参考,但是可能并不能完全解决您的安装问题。当然您也可以尝试<strong><code>ctrl+w</code></strong>。</li>
</ul>

<hr />

<h2 id="引导安装媒介">引导安装媒介</h2>

<p>大多现代操作系统允许在POST时手动设置引导设备,在开机屏幕中一般会显示需要的按键。进入BIOS设置界面后,修改设备引导顺序。把包含Arch ISO的设备设为系统引导首选。
之后让您的计算机开始常规的引导流程。
当Arch菜单出现时,选 &ldquo;Boot Arch Linux&rdquo; 并按 Enter进入安装环境.
&gt; 如果您使用 UEFI 主板,且 UEFI 启动模式（优于 BIOS/Legacy 模式）已启用,CD/USB 会自动通过systemd-boot 启动 Arch Linux。</p>

<h2 id="准备存储设备">准备存储设备</h2>

<h3 id="设备识别"><strong>设备识别</strong></h3>

<blockquote>
<p>首先要确定系统安装的目标设备,下面命令会显示所有连接到系统的设备和分区状况:</p>
</blockquote>

<pre><code># lsblk
</code></pre>

<p>磁盘设备名一般以 sdX 的形式出现,如果设备上有分区,会以 sdXY的名称出现。rom, loop 或 airoot 格式的分区可以忽略。</p>

<p>如果不需要重新分区,可以跳到 #创建文件系统,否则继续。</p>

<h3 id="分区"><strong>分区</strong></h3>

<p>硬盘首先要分区,接着将分区格式化为需要的文件系统。
有两种分区类型:
* GUID分区表(GPT)
* 主引导记录(MBR)</p>

<h3 id="创建新的分区表"><strong>创建新的分区表</strong></h3>

<p>Arch 安装盘中包含了多种分区工具,本文使用parted进行.
&gt; 打开需要新建分区表的设备</p>

<pre><code># parted /dev/sdx
</code></pre>

<p>为 BIOS 系统创建 MBR/msdos 分区表</p>

<pre><code>(parted) mklabel msdos
</code></pre>

<p>为 UEFI 系统创建 GPT 分区表</p>

<pre><code>(parted) mklabel gpt
</code></pre>

<p>用下面命令创建分区</p>

<pre><code>(parted) mkpart part-type fs-type start end
</code></pre>

<p><strong>我的分区方案(BIOS/MBR)</strong></p>

<pre><code>(parted) mkpart primary ext4 1M 300M         # /boot
(parted) set 1 boot on
(parted) mkpart primary ext4 300M 20G        # /
(parted) mkpart primary linux-swap 20G 28G
(parted) mkpart primary ext4 28G 100%        # /home
</code></pre>

<p><strong>UEFI/GPT示例</strong>
&gt; 首先需要一个 EFI 系统分区.如果是和 Windows 双系统启动,此分区已经存在,不要重新创建。
使用下面命令创建 (建议大小是 512MiB)。</p>

<pre><code>(parted) mkpart ESP fat32 1M 513M
(parted) set 1 boot on
</code></pre>

<p>其余分区可参考MBR,基本没有差别</p>

<h3 id="关于swap分区"><strong>关于swap分区</strong></h3>

<p>Swap分区在系统的物理内存不够用的时候,把硬盘空间中的一部分空间释放出来,以供当前运行的程序使用。那些被释放的空间可能来自一些很长时间没有什么操作的程序,这些被释放的空间被临时保存到Swap分区中,等到那些程序要运行时,再从Swap分区中恢复保存的数据到内存中。下面是查询Red Hat推荐的系统swap空间:</p>

<table>
<thead>
<tr>
<th align="center">系统RAM容量</th>
<th align="center">建议swap空间大小</th>
<th align="center">允许休眠的建议swap空间大小</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">&lt;=2GB</td>
<td align="center">RAM容量的2倍</td>
<td align="center">RAM容量的3倍</td>
</tr>

<tr>
<td align="center">2GB~8GB</td>
<td align="center">与RAM容量相等</td>
<td align="center">RAM容量的2倍</td>
</tr>

<tr>
<td align="center">8GB~64GB</td>
<td align="center">RAM容量的0.5倍</td>
<td align="center">RAM容量的1.5倍</td>
</tr>

<tr>
<td align="center">&gt;=64GB</td>
<td align="center">独立负载</td>
<td align="center">不建议使用休眠功能</td>
</tr>
</tbody>
</table>

<h3 id="格式化文件系统"><strong>格式化文件系统</strong></h3>

<blockquote>
<p>如果新创建了 UEFI 系统分区,需要格式化成 fat32 或 vfat32 文件系统,否则无法启动。Windows 双启动系统不要再格式化。</p>
</blockquote>

<pre><code># mkfs.vfat -F32 /dev/sdxY
</code></pre>

<p>建议用 ext4 文件系统格式化其它分区</p>

<pre><code># mkfs.ext4 /dev/sdxY
</code></pre>

<p>若分了swap分区</p>

<pre><code># mkswap /dev/sdaX
# swapon /dev/sdaX
</code></pre>

<h3 id="挂载分区-根据自己的分区方案自行调整"><strong>挂载分区</strong>(<em>根据自己的分区方案自行调整</em>)</h3>

<pre><code># mount /dev/sda2 /mnt
# mkdir /mnt/{boot,home}
# mount /dev/sda1 /mnt/boot
# mount /dev/sda4 /mnt/home
</code></pre>

<h2 id="网络连接">网络连接</h2>

<p>网络设备名可以通过 <code>ip link</code> 或 <code>iw dev</code>(无线网络)可以查到设备名称。通常以en(ethernet), wl(WLAN)或 ww(WWAN)开头。启用或禁用网络端口通过:</p>

<pre><code># ip link set eth0 up
# ip link set eth0 down
</code></pre>

<h3 id="有线连接">有线连接</h3>

<p>安装程序会在启动时自动运行dhcpcd守护进程以尝试有线连接。</p>

<h3 id="无线连接">无线连接</h3>

<p>使用 netctl 的 wifi-menu 连接到无线网络:</p>

<pre><code># wifi-menu -o wlp8s0  (笔者的无线网络设备名)
</code></pre>

<h3 id="手动配置">手动配置</h3>

<p>arch给出了很多网络配置模块,进入<code>/etc/netctl</code>下查看模版文件,进行手动配置
为了防止冲突,先关闭dhcpcd服务。</p>

<pre><code># systemctl stop dhcpcd@enp7s0.service  (enp7s0是笔者的网络设备名)
</code></pre>

<p>然后启动:</p>

<pre><code># netctl start profile[配置文件]
</code></pre>

<h4 id="有线"><em>有线</em></h4>

<ul>
<li>dhcp
<code>
/etc/netctl/my_dhcp_rofile
----------------------------
Interface=enp7s0
IP=dhcp
</code></li>

<li><p>static</p>

<pre><code>/etc/netctl/my_static_rofile
----------------------------
Interface=enp7s0
Connection=ethernet
IP=static
Address=('192.168.10.2/24')  #此处的/24相当于netmask(255.255.255.0)
Gateway='192.168.10.1'
DNS=('192.168.10.1')
</code></pre>

<h4 id="无线-wpa-psk"><em>无线(WPA-PSK)</em></h4>

<p>用<code>wpa_passphrase</code>中的方法生成256位PSK:</p>

<pre><code># wpa_passphrase your_essid passphrase
-------------------------------------
network={
ssid=&quot;your_essid&quot;
#psk=&quot;passphrase&quot;
psk=64cf3ced850ecef39197bb7b7b301fc39437a6aa6c6a599d0534b16af578e04a
}
</code></pre>

<pre><code>/etc/netctl/wireless-wpa
-------------------------
Description='A simple WPA encrypted wireless connection using 256-bit PSK'
Interface=wlp8s0
Connection=wireless
Security=wpa
IP=dhcp
ESSID=your_essid
Key=\&quot;64cf3ced850ecef39197bb7b7b301fc39437a6aa6c6a599d0534b16af578e04a
</code></pre>

<blockquote>
<p>如果密码没有起作用,从变量 Key 中删除 <code>\&quot;</code></p>
</blockquote></li>
</ul>

<p>联网之后,你需要安装一个基本系统了:一个简单的,只有内核、网络环境和基本编译环境的系统。</p>

<p><font size="+2" color="red"><strong>Note Note Note</strong>(重要的事情说三遍！！)</font></p>

<p>此刻你正在运行的系统并不是我们要安装的新系统,新系统会被安装到硬盘。
所以我们做的事就是:利用此刻的系统及网络环境一点点地从一个基本系统开始搭建新系统,
直到新系统有了基本的环境和网络,然后重启进入新系统搭建自身。</p>

<h2 id="安装啦">安装啦</h2>

<h3 id="选择安装镜像-更新源"><strong>选择安装镜像,更新源</strong></h3>

<p>pacman 会依次尝试列表中的源,所以列表中排的越靠前的镜像站优先级越高。(推荐ustc):</p>

<pre><code># sed -i &quot;s/^\b/#/g&quot; /etc/pacman.d/mirrorlist
# vi /etc/pacman.d/mirrorlist
------------------------------------------------------------
Server = http://mirrors.ustc.edu.cn/archlinux/$repo/os/$arch
Server = http://mirrors.163.com/archlinux/$repo/os/$arch
Server = http://mirrors.sohu.com/archlinux/$repo/os/$arch
</code></pre>

<p>然后进行源的更新</p>

<pre><code># pacman -Syy
</code></pre>

<blockquote>
<p>据说在旧版Arch的mirrorlist列表中,所有的Taiwan后面都有“Province of China”！</p>
</blockquote>

<h3 id="安装基本软件包">安装基本软件包</h3>

<pre><code># pacstrap -i /mnt base base-devel
</code></pre>

<p>另外新系统想要搭建自身,必须要有网络环境。</p>

<pre><code># pacstrap -i /mnt wpa_supplicant dialog ppp
</code></pre>

<h2 id="配置">配置</h2>

<h3 id="生成fstab">生成fstab</h3>

<p>把你辛苦挂载好的分区写入新系统的fstab,(UUID 能唯一且独立地标识)</p>

<pre><code># genfstab -U -p /mnt &gt;&gt; /mnt/etc/fstab  (使用卷标的话将-U改为-L)
</code></pre>

<p>如果你是arch win 双系统,别忘了</p>

<pre><code># vi /mnt/etc/fstab
------------------------------------------------------------------
# #把你的ntfs 分区也写进去,典型的例如：
/dev/sdax       /mnt/sdax       ntfs-3g defaults,umask=000    0  0
</code></pre>

<p>当然也必须把ntfs-3g 装上。</p>

<pre><code># pacstrap /mnt ntfs-3g
</code></pre>

<h3 id="chroot">chroot</h3>

<p>现在新系统已经拥有了基本环境了,chroot到新系统,并指定bash</p>

<pre><code># arch-chroot /mnt /bin/bash
</code></pre>

<h3 id="主机名">主机名</h3>

<p>设置自己喜欢的主机名:(笔者horc-pc)</p>

<pre><code># echo horc-pc &gt; /etc/hostname
</code></pre>

<p>在 <code>/etc/hosts</code>的::1 后添加同样的主机名:</p>

<pre><code># vi /etc/hosts
-----------------------------------------------------------
#&lt;ip-address&gt;	&lt;hostname.domain.org&gt;	       &lt;hostname&gt;
127.0.0.1	localhost.localdomain localhost
::1		    localhost.localdomain localhost	    horc-pc
</code></pre>

<h3 id="locale">Locale</h3>

<p>本地化的程序与库若要本地化文本,都依赖 Locale。设置下locale,进入<code>/etc/locale.gen</code>去掉前面的注释。</p>

<pre><code># vi /etc/locale.gen
--------------------
en_US.UTF-8 UTF-8
zh_CN.UTF-8 UTF-8
zh_TW.UTF-8 UTF-8
</code></pre>

<p>接着生成locale讯息:</p>

<pre><code># locale-gen
</code></pre>

<p>创建 locale.conf 并提交本地化选项:</p>

<pre><code># echo LANG=en_US.UTF-8 &gt; /etc/locale.conf
</code></pre>

<h3 id="终端字体和键盘映射"><strong>终端字体和键盘映射</strong></h3>

<p>Note: 对于大多中文用户，可忽略此章节。若要编辑可以修改<code>/etc/vconsole.conf</code>。
&gt; 警告: 如果您设置的 KEYMAP 与 loadkeys 变量并不一样,当修改密码重登时,可能无法正常登陆,一些键在两种布局的映射下并不一致。</p>

<h3 id="时间"><strong>时间</strong></h3>

<p>别忘了设置一下时区,大陆通常用上海</p>

<pre><code># ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
</code></pre>

<p>建议设置时间标准 为 UTC,并调整 时间漂移:</p>

<pre><code># hwclock --systohc --utc
</code></pre>

<p>如果你使用双系统且时间如果不同步,可能需要把硬件时钟同步为本地时间:</p>

<pre><code># hwclock --systohc --localtime
</code></pre>

<h3 id="创建初始-ramdisk-环境">创建初始 ramdisk 环境</h3>

<p>需要生成initramfs,虚拟化内存盘是Arch 加载内核所必须的</p>

<pre><code># mkinitcpio -p linux
</code></pre>

<h2 id="安装启动器-bootloader"><strong>安装启动器(bootloader)</strong></h2>

<h3 id="bios-mbr">BIOS/MBR</h3>

<p>安装grub2 来引导arch (没用syslinux 引导过)</p>

<pre><code># pacman -S grub-bios
# # pacman -S os-prober (双系统用户需要)
# grub-install /dev/sdx
</code></pre>

<p>可以修改下grub 的配置选项,例如默认等待时间和主题等等</p>

<pre><code># vi /etc/default/grub
</code></pre>

<p>下面命令会自动生成配置文件:</p>

<pre><code># grub-mkconfig -o /boot/grub/grub.cfg
</code></pre>

<p>PS:如果忘记创建GRUB配置文件/boot/grub/grub.cfg,然后直接重启到了GRUB命令行界面,输入以下命令:</p>

<pre><code>sh:grub&gt; insmod legacycfg
sh:grub&gt; legacy_configfile ${prefix}/menu.lst
</code></pre>

<p>选择启动到Arch下然后再重新创建合适的GRUB配置文件/boot/grub/grub.cfg
&gt; Note:不过笔者这里失败了,屡试未果只好重装了,所以各位萌新最好别忘记了.</p>

<h3 id="uefi-gpt">UEFI/GPT</h3>

<pre><code># bootctl install
</code></pre>

<p>成功执行以上命令之后,为系统创建一个引导入口。或使用 /usr/share/systemd/bootctl/ 的示例配置文件。此处提供两个示例文件:</p>

<pre><code># vi /boot/loader/entries/arch.conf
-----------------------------------
title          Arch Linux
linux          /vmlinuz-linux
initrd         /initramfs-linux.img
options        root=/dev/sdaX rw
</code></pre>

<pre><code># vi /boot/loader/loader.conf
-----------------------------
default  arch
timeout  5
editor   0
</code></pre>

<h2 id="网络配置">网络配置</h2>

<h3 id="有线-1">有线</h3>

<p>该过程与#建立网络连接基本一致。
如果只用单一且固定的有线网络连接,启动 dhcpcd 服务</p>

<pre><code># systemctl enable dhcpcd@interface.service  (interface是网络接口名)
</code></pre>

<h3 id="无线">无线</h3>

<p>如果之前未安装 wpa_supplicant dialog 的话,这里可以安装,需要它们联网</p>

<pre><code># pacman -S wpa_supplicant dialog
</code></pre>

<p>然后可参考之前的连接方法.</p>

<h3 id="adsl宽带连接">ADSL宽带连接</h3>

<pre><code># pacman -S rp-pppoe
# pppoe-setup    # 配置
# systemctl start adsl    # 连接
# # systemctl enable adsl 以自动连接
</code></pre>

<h2 id="用户管理">用户管理</h2>

<h3 id="设置root密码"><strong>设置Root密码</strong></h3>

<pre><code> # passwd
</code></pre>

<h3 id="创建一个日常用户"><strong>创建一个日常用户</strong></h3>

<p>这里添加wheel用户组是为了能够使用sudo提权,毕竟直接拿着root(root == 老婆{手动坏笑}),不小心按出&rsquo;rm -rf /*&lsquo;等等操作还是很危险的。(没错我经常这么干~)</p>

<pre><code># useradd -m -g users -G wheel -s /bin/bash new_Username
# passwd new_Username
</code></pre>

<h2 id="卸载分区并重启系统"><strong>卸载分区并重启系统</strong></h2>

<p>退出chroot,卸载分区,然后reboot。</p>

<pre><code># exit
# umount /mnt/{boot,home}
# umount /mnt
# reboot
</code></pre>

<p>移除安装媒介,并还原 BIOS 中的启动选项。至此已经获得了一个完全可用的Arch-Linux！</p>

<hr />

<h1 id="额外安装">额外安装</h1>

<h2 id="声音管理">声音管理</h2>

<h3 id="安装声卡驱动"><strong>安装声卡驱动</strong></h3>

<pre><code># pacman -S alsa-utils
</code></pre>

<p>Arch Linux默认开启了声音支持,默认静音。可通过 alsamixer(所属包:alsa-utils) 取消静音:
* 方向键 选中 Master 和 PCM
* [M] 取消静音</p>

<h2 id="配置图形界面">配置图形界面</h2>

<h3 id="安装显卡驱动"><strong>安装显卡驱动</strong></h3>

<pre><code># lspci | grep VGA    # 确定显卡型号
# pacman -S &lt;驱动包&gt;
</code></pre>

<p>官方仓库提供的驱动包:</p>

<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">开源</th>
<th align="center">私有</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">general</td>
<td align="center">xf86-video-vesa</td>
<td align="center"></td>
</tr>

<tr>
<td align="center">Intel</td>
<td align="center">xf86-video-intel</td>
<td align="center"></td>
</tr>

<tr>
<td align="center">nVidia GeForce 7+</td>
<td align="center">xf86-video-nouveau</td>
<td align="center">nvidia</td>
</tr>

<tr>
<td align="center">nVidia GeForce <sup>6</sup>&frasl;<sub>7</sub></td>
<td align="center">xf86-video-nouveau</td>
<td align="center">nvidia-304xx</td>
</tr>

<tr>
<td align="center">AMD/ATI</td>
<td align="center">xf86-video-ati</td>
<td align="center"></td>
</tr>

<tr>
<td align="center">VMware</td>
<td align="center">xf86-video-vmware</td>
<td align="center"></td>
</tr>
</tbody>
</table>

<h3 id="安装-x-窗口系统"><strong>安装 X 窗口系统</strong></h3>

<blockquote>
<p>X 窗口管理系统(X11或者X) 是基于网络的显示协议,提供了窗口功能,包含建立图形用户界面(GUI)的标准工具和协议。Xorg是X窗口系统11版本的开源实现,提供图形用户界面</p>
</blockquote>

<pre><code># pacman -S xorg-server xorg-server-utils    # 安装 Xorg Server
# pacman -S xf86-input-synaptics    # 可选，触摸板支持
# pacman -S ttf-dejavu wqy-microhei    # 可选，Dejavu 与文泉驿 - 微米黑字体
</code></pre>

<h3 id="安装桌面环境"><strong>安装桌面环境</strong></h3>

<blockquote>
<p>Xorg只提供图形环境的基本框架,完整的用户体验还需要其他组件。桌面环境(DE):在X之上并与其共同运作,提供完整的功能和动态图形界面。桌面环境通常提供图标、小程序(applets)、窗口、工具栏、文件夹、壁纸、应用程序和拖放等功能。</p>
</blockquote>

<p>官方提供的桌面环境有:</p>

<ul>
<li>Cinnamon: cinnamon</li>
<li>Enlightenment: enlightenment17</li>
<li>GNOME: gnome gnome-extra</li>
<li>KDE: kde kde-l10n-zh_cn</li>
<li>LXDE: lxde</li>
<li>Xfce: xfce4 xfce4-goodies</li>
<li>其他桌面环境</li>
</ul>

<pre><code># pacman -S xfce4   #我选择了xfce4,很轻量的桌面
</code></pre>

<p>窗口管理器
&gt; 完整的桌面环境提供了完全的用户界面,但是通常会占用不少系统资源。希望系统性能最大化的用户可以只安装窗口管理器,然后加入需要的其他软件。大部分的桌面环境都可以换用其它的窗口管理器。 动态,堆栈式和平铺 窗口管理器处理窗口的方式各不相同。</p>

<p>显示管理器
&gt; 可以让图形界面自动启动,但我并未安装(我喜欢为所欲为:-)),因为并不需要自动启动桌面,想启动的时候再启动呗.</p>

<p>桌面环境的启动方式主要有两种:</p>

<ul>
<li>startx</li>
<li>显示管理器</li>
</ul>

<p>安装完xfce4后,键入:</p>

<pre><code># startxfce4  #启动xfce桌面session
</code></pre>

<p>可以复制/etc/X11/xinit/xinitrc至家目录下隐藏(如果家目录下已存在.xinitrc,可直接修改),修改最下方的启动信息:</p>

<pre><code># cp /etc/X11/xinit/xinitrc ~/.xinitrc
# vi ~/.xinitrc
--------------------------------------
exec xfce4-session
</code></pre>

<hr />

<h1 id="其它安装">其它安装</h1>

<p>这里开始就是最耗费精力的时候了,各种应用还请根据个人需求和喜好进行安装,这里就不进行说明了。</p>

<hr />

<h1 id="pacman">pacman</h1>

<p>pacman?吃豆人？
嘿嘿,其实Arch中的pacman就等同于Debian系中的apt-get,Red Hat系中的dnf/yum这种包管理器。</p>

<p>下面列举几个pacman的常用命令,其余的可以通过</p>

<pre><code># pacman --help #查看帮助信息
# man pacman  #获取更为详细的信息
</code></pre>

<p><strong>同步与升级</strong></p>

<pre><code># pacman -Syy  #同步本地的包数据库和远程的软件仓库
# pacman -Syu  #同时进行同步软件库并更新系统到最新状态
</code></pre>

<p><strong>安装软件包</strong></p>

<pre><code># pacman -S package_name1 package_name2  #安装或者升级单个软件包,或者一列软件包(包含依赖包)
# pacman -S extra/package_name  #一个软件包有多个版本(比如extra和testing)
# pacman -S testing/package_name  #选择其中一个版本进行安装
# pacman -Sy package_name  #同步包数据库并且安装一个软件包
</code></pre>

<p><strong>卸载软件包</strong></p>

<pre><code># pacman -R package_name    #删除单个软件包,留其全部已经安装的依赖
# pacman -Rs package_name   #删除指定软件包,及其所有没有被其他已安装软件包使用的相关依赖
</code></pre>

<p><strong>包数据库查询</strong></p>

<pre><code># pacman -Ss package #查询软件包
# pacman -Qs package #查询已安装的包
# pacman -Qi package #显示查找的包的信息
# pacman -Ql package #显示你要找的包的文件都安装的位置
</code></pre>

<p><strong>其它</strong></p>

<pre><code># pacman -U /path/package.pkg.tar.gz #安装本地包
# pacman -Sf pacman #重新安装包
# pacman -Sw package #下载但不安装包
# pacman -Scc #清理包缓存，下载的包会在/var/cache 这个目录
# ...
</code></pre>

<h2 id="最后说两句">最后说两句</h2>

<p>2016-5-1:
其实个人折腾Arch也好几次了,不断地倒腾,算有一点点的小心得。</p>

<p>2016-6-7:
哈哈，最近把DE从Xfce4换成了lxqt尝尝鲜,感觉瞬间高大上了不少~</p>

<h1 id="参考">参考</h1>

<p>[1]. <font size="+1" style="color: #00FFFF;"><a href="http://blog.csdn.net/ispeller/article/details/9327389">关于Archlinux 的安装</a></font><br/>
[2]. <font size="+1" style="color: #00FFFF;"><a href="https://wiki.archlinux.org/">archlinux 官方 wiki</a></font><br/>
[3]. <font size="+1" style="color: #00FFFF;"><a href="blog.lucode.net/linux/archlinux-install-tutorial.html">archlinux安装教程</a></font><br/>
[4]. <font size="+1" style="color: #00FFFF;"><a href="https://access.redhat.com/documentation/en/red-hat-enterprise-linux/">red hat官网参考文档</a></font><br/></p>

      </div>
    </section>
    
    <section class="pagination clearfix">
       
      
      <a class="btn next " href="https://horc-fn.github.io/note/blog/"> Hexo 搭建静态博客 </a> 
      
    </section>
    
    
  </div>
  
  <footer>
  <div class="footer-info">
    <p>
      <div id="ldmuisc">
        
      </div>
      <a href="mailto:horcxc@sina.com?subject="><i class="fa fa-envelope-o"></i> horcxc@sina.com </a>
      {
        <a href="https://gohugo.io/" title="Hugo :: A fast and modern static website engine">Hugo 0.16</a>,
        <a href="https://github.com/IvanChou/yii.im" title="vec">Vec</a> 
      }
      {<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/" title="CC BY-NC-ND 3.0">CC BY-NC-ND 3.0</a>}
      
    </p>
    
  </div>
  <script>
    window.onload = function(){
      var bgm1 = document.createElement("audio");
      bgm1.loop = true;
      bgm1.src = "/audio/ty1.mp3";
      
      document.getElementById("ldmuisc").appendChild(bgm1);
      if (bgm1.paused){
        bgm1.play();
      }
    }
    function hasClass(obj, cls) {
          return obj.className.match(new RegExp('(\\s|^)' + cls + '(\\s|$)'));
    }

    function addClass(obj, cls) {
        if (!this.hasClass(obj, cls)) obj.className += " " + cls;
    }

    function removeClass(obj, cls) {
        if (hasClass(obj, cls)) {
            var reg = new RegExp('(\\s|^)' + cls + '(\\s|$)');
            obj.className = obj.className.replace(reg, ' ');
        }
    }
    
  </script>
</footer>
  
  <script src="https://horc-fn.github.io/js/highlight.min.js"></script>
  <script>
    hljs.initHighlightingOnLoad();
  </script>
  <script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'Your Google Analytics tracking code', 'auto');
ga('send', 'pageview');

</script>
</body>

</html>
